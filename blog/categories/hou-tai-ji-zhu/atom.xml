<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 后台技术 | Tianyi's blog]]></title>
  <link href="http://xbox1994.github.io/blog/categories/hou-tai-ji-zhu/atom.xml" rel="self"/>
  <link href="http://xbox1994.github.io/"/>
  <updated>2017-01-16T22:50:25+08:00</updated>
  <id>http://xbox1994.github.io/</id>
  <author>
    <name><![CDATA[Tianyi Wang]]></name>
    <email><![CDATA[tywang@thoughtworks.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SSH登录原理简介]]></title>
    <link href="http://xbox1994.github.io/blog/2017/01/16/sshdeng-lu-yuan-li-jian-jie/"/>
    <updated>2017-01-16T22:19:46+08:00</updated>
    <id>http://xbox1994.github.io/blog/2017/01/16/sshdeng-lu-yuan-li-jian-jie</id>
    <content type="html"><![CDATA[<p>每次都用SSH登录,却没有关心过其中的原理,实在没脸用SSH</p>

<!--more-->


<h2>什么是SSH?</h2>

<p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。</p>

<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p>

<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p>

<p>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。</p>

<p>转自<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p>

<h2>从用到懂</h2>

<h3>用</h3>

<p>  Secure Shell is a protocol used to securely log onto remote systems.
  It can be used for logging or executing commands on a remote server.</p>

<ul>
<li><p>Connect to a remote server:<br/>
ssh username@remote_host</p></li>
<li><p>Connect to a remote server with a specific identity (private key):<br/>
ssh -i path/to/key_file username@remote_host</p></li>
<li><p>Connect to a remote server using a specific port:<br/>
ssh username@remote_host -p 2222</p></li>
<li><p>Run a command on a remote server:<br/>
ssh remote_host command -with -flags</p></li>
<li><p>SSH tunneling: Dynamic port forwarding (SOCKS proxy on localhost:9999):<br/>
ssh -D 9999 -C username@remote_host</p></li>
<li><p>SSH tunneling: Forward a specific port (localhost:9999 to slashdot.org:80):<br/>
man ssh_config</p></li>
<li><p>Enable the option to forward the authentication information to the remote machine (see man ssh_config for available options):<br/>
ssh -o &ldquo;ForwardAgent=yes&rdquo; username@remote_host</p></li>
</ul>


<p>引用自tldr(与fuck一样是一辈子都要用的,实在是太好用了)</p>

<p>具体配置SSH客户端的文件在
  - ~/.ssh/config
  - /etc/ssh/ssh_config</p>

<p>ssh_config &ndash; OpenSSH SSH client configuration files,与SSH连接的配置项,如超时控制,连接策略</p>

<h3>懂</h3>

<p>SSH之所以能够保证安全，原因在于它采用了公钥加密。<br/>
（1）远程主机收到用户的登录请求，把自己的公钥发给用户。<br/>
（2）用户使用这个公钥，将登录密码加密后，发送回来。<br/>
（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p>

<p>SSH公钥登录：<br/>
用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>

<p>SSH私钥登录：<br/>
类似公钥登录，前提是将一个公钥存储在远程主机上，然后加一个i参数使用这个公钥对应的私钥去加密字符串发送给服务器</p>

<h3>安全威胁</h3>

<p>如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了,这就是中间人攻击,对于这个问题,SSH有自己的一套简易防范措施:</p>

<p>第一次连接时会显示公钥指纹，跟对方确认后连接，一般是在官方网站上有对应指纹提供给用户验证,当选择yes,就会将该主机的公钥追加到该主机本地文件~/.ssh/known_hosts中。当再次连接该主机时，会比对这次连接的主机公钥与之前保存的公钥是否一致</p>

<p>如果因为某种原因（服务器系统重装，服务器间IP地址交换，DHCP，虚拟机重建，中间人劫持），该IP地址的公钥改变了，当使用 SSH 连接的时候，会报错：Host key verification failed.</p>

<p>如果自己可以确认对方域名是绝对安全可靠的,即使IP变动也是正常的话,那么可以使用如下方式省去验证步骤:<br/>
只需要修改 /etc/ssh/ssh_config 文件，包含下列语句：<br/>
Host *<br/>
 StrictHostKeyChecking no<br/>
或者在 ssh 命令行中用 -o 参数<br/>
ssh  -o StrictHostKeyChecking=no  192.168.0.110</p>

<p>如果设置了无口令 SSH 登录（即通过客户端公钥认证），就可以直接连接到远程主机。这是基于 SSH 协议的自动化任务常用的手段。</p>

<p>部分引用自:<a href="http://www.worldhello.net/2010/04/08/1026.html">http://www.worldhello.net/2010/04/08/1026.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一次性能优化探索-Nginx有什么用]]></title>
    <link href="http://xbox1994.github.io/blog/2017/01/08/mou-ci-you-hua-shi-jian-nginxshi-na-lai-gan-shi-yao-de/"/>
    <updated>2017-01-08T18:32:58+08:00</updated>
    <id>http://xbox1994.github.io/blog/2017/01/08/mou-ci-you-hua-shi-jian-nginxshi-na-lai-gan-shi-yao-de</id>
    <content type="html"><![CDATA[<p>&ldquo;这张卡马上做完了,赶紧desk check,我们先把测试环境准备好&rdquo;.我高高兴兴地跟洲说,随手修改了一下配置文件中的微服务访问路径,然后重启服务器,一切看起来那么的一帆风顺.<br/>
&ldquo;好的,页面开始Loading啦&rdquo;&hellip;10分钟之后&hellip;&ldquo;我受不了了&rdquo;</p>

<!--more-->


<h2>问题</h2>

<p>1.本地环境开启的应用访问EC2上的某微服务速度慢,但在EC2环境开启的应用访问该微服务速度快.</p>

<p>2.本地环境加载某一个页面的过程中刷新,会很长时间内没有回应</p>

<h2>区别</h2>

<p>本地应用环境与EC2真实环境局别如下:<br/>
1.本地与EC2其他微服务的连接是外网通信,运行应用的EC2实例与其他微服务的连接是内网通信<br/>
2.本地Web Server使用的是Thin,EC2服务器使用的是Unicorn+Nginx</p>

<h2>猜测</h2>

<p>首先我们觉得是网络环境的问题,因为我们同时发现上午网速确实比下午网速快,所以忍耐了很长时间没有下功夫在这方面,直到最近洲回来了,对这个访问速度感到很是愤怒.
在连接上VPN之后,发现速度什么的都不是问题,但是加载数据量较大的资源时还是比较慢</p>

<h2>研究</h2>

<p>问题1:</p>

<p>所以开始研究第二个区别,本地测试三种环境如下图:<br/>
1)Thin<br/>
<img src="/images/blog/home_thin.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" >
2)Unicorn<br/>
<img src="/images/blog/home_unicorn.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" >
3)Unicorn+Nginx
<img src="/images/blog/home_nginx+unicorn.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>可以看出:<br/>
1.对于Thin和Unicorn服务器来说,资源不论大小,他们的耗时是基本相同的.<br/>
2.拿有Nginx的Unicorn服务器与没有Nginx的Unicorn服务器来说,数据量小的资源会稍慢一些,但数据量大的资源速度提升明显.<br/>
3.Nginx将数据进行大幅度压缩,导致Size远小于Content</p>

<p>问题2:</p>

<p>经过测试,1)和2)都存在这个问题,但3)不存在,很明显是默认配置的服务器无法同时处理多个请求,可以通过
1.&ndash;threaded开启Thin多线程模式<br/>
2.Nginx与多进程模式Unicorn的配合<br/>
均可以使得不用等待上一个请求结束而直接请求另一个服务器并立马得到回应.</p>

<h2>服务器通信级别的原因</h2>

<h3>Nginx对请求的压缩处理</h3>

<p>具体解释与参数配置在<br/>
<a href="https://www.nginx.com/resources/admin-guide/compression-and-decompression/">https://www.nginx.com/resources/admin-guide/compression-and-decompression/</a></p>

<p>gzip是默认配置在nginx.conf内的,所以默认开启,如果不对数据量要求特别精细的话,默认配置完全可以满足基本需求</p>

<p>上图的2.5MB大文件显然被压缩成几百K的小文件在网络上进行传输,大大减轻了应用的网络负载</p>

<h3>Nginx对请求的合并处理</h3>

<p>先回顾一下Nginx反向代理的原理:正向代理是将自己要访问的资源告诉Proxy,让Proxy帮你拿到数据返回给你,Proxy服务于Client,常用于翻墙和跨权限操作;反向代理也是将自己要访问的资源告诉Proxy,让Proxy帮你拿到数据返回给你,但是Proxy服务于Server,它会将请求接受完毕之后发送给某一合适的Server,常用于负载均衡.</p>

<p><img src="/images/blog/nginx_priciple.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p><strong><em>Proxy统一接收Client请求，接收完毕后才发给Server，提高Server处理效率</em></strong></p>

<p>Using a reverse proxy server frees the application server from having to wait for users to interact with the web app and lets it concentrate on building pages for the reverse proxy server to send across the Internet<br/>
<a href="https://www.nginx.com/blog/10-tips-for-10x-application-performance/">https://www.nginx.com/blog/10-tips-for-10x-application-performance/</a></p>

<p>Nginx在其他方面也有好处,如直接返回静态文件,添加重定向与SSL证书,添加返回头,可参看这篇[NUS后台]</p>

<h3>少量请求+单机运行Nginx的坏处</h3>

<p>Nginx是负责接收/返回请求与转发/返回请求的,在这个过程中会涉及到资源的压缩处理,势必会拖慢请求处理速度并加重Nginx运行环境的负担;同时,在转发到Server和接受Server返回的资源的过程中是会进行TCP连接的,此段的开销会拖慢整体返回速度,所以可能会出现单个请求返回速度比不使用Nginx的速度慢.</p>

<p>但是,在高并发情况下,才是Nginx的用武之地.如果1台实例无法处理成千上万个请求,那么就用集群吧,Nginx帮你负载均衡并添加一道隐形的安全防火墙,记住,一定要把Nginx放到一台独立的实例上而不要与其他服务共存,否则反而会影响整体处理速度.</p>

<p>换句话说,使用Nginx的后台架构中的单个请求的处理速度可能会慢于不使用Nginx的后台架构,但在高并发环境下,不使用Nginx的后台可能会爆掉Out of memory..使用Nginx的后台依然坚挺,为了系统的稳定性与负载均衡,使用Nginx是非常明智的选择.</p>

<h2>代码级别的原因</h2>

<p>上面是针对已有代码进行的服务器通信阶段进行的分析,在代码内部实现,依然还有很多加快加载速度的方式,对于我们这个例子来说的话:<br/>
1.前台不应该加载2.5MB这样巨大的文件,除非万不得已.在前台做数据的展现即可,不需要先拿到全部数据后做数据的查询.<br/>
2.代码级别存在很多批处理请求,但发送的时候是单条发送,建议使用批量处理对应的API</p>

<h2>结论</h2>

<p>1.网络问题是影响本地加载速度最大的因素,本地网络暂时难以改变,不连接/连接VPN+添加防火墙规则解决.<br/>
2.代码层级可以做适当优化,解决大资源加载以及请求发送策略,将要解决.<br/>
3.对于页面重新加载速度过慢的问题,使用多线程配置解决,已经解决.<br/>
4.对于大资源加载问题,考虑使用Nginx压缩处理,grunt ddev已经解决.<br/>
5.对于以后可能出现的请求数量过多问题采用Nginx+Unicorn负载均衡,已经解决.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NUS后台]]></title>
    <link href="http://xbox1994.github.io/blog/2016/12/18/nusde-hou-tai/"/>
    <updated>2016-12-18T16:12:24+08:00</updated>
    <id>http://xbox1994.github.io/blog/2016/12/18/nusde-hou-tai</id>
    <content type="html"><![CDATA[<p>Nginx Unicorn Sinatra<br/>
研究一个后台架构,客户端发送的请求最开始是由是Nginx接收的,随后反向代理发送给Unicorn服务器的一个线程,接下来是Sinatra框架和Rack负责处理</p>

<!--more-->


<h3>Nginx</h3>

<p>是一个高性能的HTTP和反向代理服务器</p>

<p>根据以下文件你可以发现在SF中我们是如何使用nginx的
infrastructure/ansible/roles.add_app_to_nginx/files/sales_refresh_app_nginx_config</p>

<pre><code>server {
    #监听端口号
    listen 80;
    #会根据收到的HOST来匹配哪一个server，这样随便写没有匹配到的，那么第一个就是默认的
    server_name _;
    #重定向http请求为https
    return 301 https://$http_host$request_uri;
}

upstream unicorn_server {
    #IPC方式与unicorn通信，unicorn.rb
    server unix:/usr/share/nginx/sales_refresh_app/tmp/sockets/unicorn.sock
    #0让nginx反复重试后端即使超时，配合下面的unicorn配置文件使用
    fail_timeout=0;
}

server {
    listen 443;
    server_name _;
    #可直接访问静态文件
    root /usr/share/nginx/sales_refresh_app/public;
    ssl on;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_certificate /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;
    location / {
    #先查找是否有可以直接访问的文件，然后再去访问app
    try_files $uri @app;
    }
    location @app {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    # pass to the upstream unicorn server mentioned above
    proxy_pass http://unicorn_server;
    }
}
</code></pre>

<p>总结：在本机上同时使用nginx和unicorn，所以用到了反向代理，没有用到负载均衡。只提供https协议访问。静态文件加速访问。配置与unicorn的关系。</p>

<h3>Unicorn</h3>

<p>Unicorn 是一个为运行 Rack 应用的HTTP服务器。
Rack是为使用Ruby开发web应用提供了一个最小的模块化和可修改的接口。用可能最简单的方式来包装HTTP请求和响应</p>

<p>与上下的关联
1. read/parse HTTP request headers in full
2. call Rack application（Sinatra）
3. write HTTP response back to the client</p>

<p>/Users/tywang/WuhanWork/sales-funnel/config.ru是入口文件
/Users/tywang/WuhanWork/sales-funnel/unicorn.rb
参考：<a href="https://unicorn.bogomips.org/Unicorn/Configurator.html#method-i-worker_processes">https://unicorn.bogomips.org/Unicorn/Configurator.html#method-i-worker_processes</a></p>

<p>unicorn.rb:</p>

<pre><code>#where do app live???
@dir = "/usr/share/nginx/sales_refresh_app/"

worker_processes 8
working_directory @dir

#设置worker_processes的超时时间（handling the request/app.call/response cycle）单位秒，如果超时将被sigkill
timeout 300

# Specify path to socket unicorn listens to,
# used in  nginx.conf 
listen "#{@dir}tmp/sockets/unicorn.sock" , :backlog =&gt; 64

# Set process id path
pid "#{@dir}tmp/pids/unicorn.pid"

# Set log file paths
stderr_path "#{@dir}log/unicorn.stderr.log"
stdout_path "#{@dir}log/unicorn.stdout.log"
</code></pre>

<p>以前碰到过的一个问题：不启用nginx和unicorn时，当程序出错，代码中不处理错误而是抛出错误会导致服务器挂掉，似乎sinatra也没有管。
答：thin是单线程的，如果代码不够健壮导致thin挂了一次就无法恢复了，unicorn是多线程的，worker_processes默认有8个哦，如果超时会被kill掉再启动的，每个worker_process只能同时服务一个client，所以并发性能很差</p>

<p>那么问题又来了，单线程如何实现高性能并发处理？
<a href="https://github.com/eventmachine/eventmachine">https://github.com/eventmachine/eventmachine</a></p>

<h3>Sinatra</h3>

<p>Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort
对我们来说就是一个Ruby开发框架，用Sinatra的写法简化我们的开发，一个基于Rack的框架</p>

<p>总结：Request->Nginx->Unicorn->Rack(Sinatra)->App</p>

<p>其他：Nginx+Unicorn+Sinatra部署方案
<a href="http://recipes.sinatrarb.com/p/deployment/nginx_proxied_to_unicorn">http://recipes.sinatrarb.com/p/deployment/nginx_proxied_to_unicorn</a></p>
]]></content>
  </entry>
  
</feed>
