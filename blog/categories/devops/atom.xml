<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Devops | Tianyi's blog]]></title>
  <link href="http://xbox1994.github.io/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://xbox1994.github.io/"/>
  <updated>2017-02-12T13:06:12+08:00</updated>
  <id>http://xbox1994.github.io/</id>
  <author>
    <name><![CDATA[Tianyi Wang]]></name>
    <email><![CDATA[tywang@thoughtworks.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Docker Port与iptables]]></title>
    <link href="http://xbox1994.github.io/blog/2017/02/04/docker-portyu-iptables/"/>
    <updated>2017-02-04T16:57:08+08:00</updated>
    <id>http://xbox1994.github.io/blog/2017/02/04/docker-portyu-iptables</id>
    <content type="html"><![CDATA[<p>一个请求是如何从实体机传递到我们的应用的</p>

<p>iptables -> docker deamon -> docker bridge network -> docker container -> app</p>

<!--more-->


<h2>从iptables开始</h2>

<p>参考:<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Security_Guide/s1-firewall-ipt-fwd.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Security_Guide/s1-firewall-ipt-fwd.html</a></p>

<p>维基百科:iptables，一个运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的流动与转送。</p>

<p>因为公网IP的稀有与昂贵,公司一般只有一个公网IP,使用局域网与私有IP是访问公网资源的常用方式.防火墙与路由器可以将请求转发到内网机器上,也可以将传入路由到对应内网节点.这样的转发很危险,特别是攻击者伪装成内网节点.为了防止这种情况，iptables提供了可以实现的路由和转发策略，以防止网络资源的异常使用。</p>

<h4>iptables的FORWARD策略</h4>

<p>控制经过本节点的数据包路由的位置,例如转发到所有节点</p>

<p>如果这样设置,在这个防火墙之后的所有节点都可以接收到数据包,相当于创建了一个路由规则,发送到这个路由的数据包都可以达到数据包内包含的预期节点,且都通过eth1设备
<code>
iptables -A FORWARD -i eth1 -j ACCEPT
iptables -A FORWARD -o eth1 -j ACCEPT
</code></p>

<p>此时内网节点还不能正常访问外网,需要将内网IP伪装成路由IP来访问外网资源
<code>
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</code></p>

<p>如果你想让一个内网节点成为外部可用的服务器,使用DNAT转发策略,将外部请求转发到改内网节点,Docker就是使用这个策略将请求转发到对应container中
<code>
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to 172.31.0.23:80
</code></p>

<h2>iptables结合docker deamon转发</h2>

<p>参考:<a href="https://wiki.archlinux.org/index.php/Network_bridge_">https://wiki.archlinux.org/index.php/Network_bridge_</a>(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) &lt;Docker进阶与实战></p>

<h4>iptables -> docker deamon</h4>

<p>Docker deamon在启动container时会在主机上采用iptables的DNAT策略,将iptables接受到的请求转发给改container所属的内网节点
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@ip-172-31-18-147:/home/ubuntu# docker run -itd -p 80:80 nginx&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;root@ip-172-31-18-147:/home/ubuntu# docker ps
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES
</span><span class='line'>660b89af3737        nginx               &ldquo;nginx -g &lsquo;daemon &hellip;&rdquo;   3 seconds ago       Up 2 seconds        0.0.0.0:80-&gt;80/tcp, 443/tcp   amazing_dijkstra
</span><span class='line'>r&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;root@ip-172-31-18-147:/home/ubuntu# iptables -L
</span><span class='line'>Chain FORWARD (policy DROP)
</span><span class='line'>target     prot opt source               destination
</span><span class='line'>DOCKER     all  &ndash;  anywhere             anywhere
</span><span class='line'>Chain DOCKER (1 references)
</span><span class='line'>target     prot opt source               destination
</span><span class='line'>ACCEPT     tcp  &ndash;  anywhere             172.17.0.2           tcp dpt:http&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>####docker deamon -&gt; docker bridge network
</span><span class='line'>Docker deamon启动时会在主机创建一个Linux网桥(网桥:网桥是一种软件配置，用于连结两个或更多个不同网段。网桥的行为就像是一台虚拟的网络交换机，工作于透明模式（即其他机器不必关注网桥的存在与否）。任意的真实物理设备（例如 eth0）和虚拟设备（例如 tap0）都可以连接到网桥。)(默认为docker0).
</span><span class='line'>
</span><span class='line'>容器启动时会创建一对veth pair,docker将一端挂在docker0网桥上,另一端放到容器的Network Namespace内,从而实现容器与主机通信的目的.
</span><span class='line'><img src="/images/blog/docker_bridge_network.png" title="image" alt="images">
</span><span class='line'>
</span><span class='line'>####docker bridge network -&gt; docker container
</span><span class='line'>当前没有容器运行,网桥上没有网络接口,但默认分配了172.17.0.1/16的子网
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;root@ip-172-31-18-147:/home/ubuntu# ip addr show docker0
</span><span class='line'>5: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default
</span><span class='line'>    link/ether 02:42:51:23:1f:10 brd ff:ff:ff:ff:ff:ff
</span><span class='line'>    inet 172.17.0.1/16 scope global docker0
</span><span class='line'>       valid_lft forever preferred_lft forever
</span><span class='line'>    inet6 fe80::42:51ff:fe23:1f10/64 scope link
</span><span class='line'>       valid_lft forever preferred_lft forever
</span><span class='line'>&lt;code&gt;
</span><span class='line'>然后启动一个container测试,container会自动加入到该子网中
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>root@ip-172-31-18-147:/home/ubuntu# docker run -it ubuntu:14.04
</span><span class='line'>root@82c955281fdb:/# ip addr show
</span><span class='line'>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default
</span><span class='line'>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span><span class='line'>    inet 127.0.0.1/8 scope host lo
</span><span class='line'>       valid_lft forever preferred_lft forever
</span><span class='line'>    inet6 ::1/128 scope host
</span><span class='line'>       valid_lft forever preferred_lft forever
</span><span class='line'>931: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
</span><span class='line'>    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
</span><span class='line'>    inet 172.17.0.2/16 scope global eth0
</span><span class='line'>       valid_lft forever preferred_lft forever
</span><span class='line'>    inet6 fe80::42:acff:fe11:2/64 scope link
</span><span class='line'>       valid_lft forever preferred_lft forever</span></code></pre></td></tr></table></div></figure></p>

<p><em><strong>综上所述,Docker会为我们创建一个iptables转发规则,将从外界接收到的请求转发到Docker在启动container时创建的子网中的对应节点</strong></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker in Docker]]></title>
    <link href="http://xbox1994.github.io/blog/2017/01/29/docker-in-docker/"/>
    <updated>2017-01-29T14:52:48+08:00</updated>
    <id>http://xbox1994.github.io/blog/2017/01/29/docker-in-docker</id>
    <content type="html"><![CDATA[<p>我想过一个非常有意思的东西:在docker里面运行docker,然后在docker里运行的docker中再运行一个docker,接着在docker里运行的docker里运行的docker中再开一个docker..接着迭代100次会发生什么</p>

<!--more-->


<p>结合这篇文章:<a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/</a>
以及自己的经验与实践总结出下文.</p>

<p>&ldquo;If you want the short solution without the details, just scroll to the bottom of this article. ☺&rdquo;</p>

<h2>Bad</h2>

<p>如果你在docker中运行了docker,会导致一下问题:</p>

<p>1.当你使用-privileged的时候会导致一个在内部docker与外部docker之间的安全配置无法合并的冲突,是关于LSM (Linux Security Modules)的</p>

<p>2.外部docker运行在正常的文件系统中,但内部docker运行在写时拷贝的文件系统,会直接导致无法运行或者因为命名空间的问题影响其他container</p>

<h2>Solution</h2>

<p>其实基本上来说是不存在需要在docker中跑docker这种需求的,你想要的只是在docker中启动一个docker的container来运行你的程序,并不关心这个container在哪个docker进程中.下面提供一种方式可以让你在docker内部调用这个docker程序开启新的container帮助你完成工作:</p>

<pre><code>docker run -v /var/run/docker.sock:/var/run/docker.sock ...
</code></pre>

<p>这样你程序所在的container中已经有权限访问docker的socket,因此可以用docker run启动同胞兄弟而不是子容器</p>

<pre><code>/ # docker ps
➜  ~ docker run -v /var/run/docker.sock:/var/run/docker.sock -ti docker
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
8c84704e890e        docker              "docker-entrypoint..."   2 seconds ago       Up 1 second                             brave_lichterman
/ # docker run -v /var/run/docker.sock:/var/run/docker.sock -ti docker
/ # docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
34dcf16326c2        docker              "docker-entrypoint..."   3 seconds ago       Up 2 seconds                            inspiring_mcnulty
8c84704e890e        docker              "docker-entrypoint..."   37 seconds ago      Up 36 seconds                           brave_lichterman
</code></pre>

<h2>Practice</h2>

<p>使用上述Solution打包一个docker镜像</p>

<h3>构建打包镜像的环境</h3>

<p>网上实在没有找到包含docker+aws+packer的ubuntu docker镜像,以下是dockerfile
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM ubuntu:14.04&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;install docker&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;RUN apt-get update \
</span><span class='line'>    &amp;&amp; apt-get -y install ca-certificates \
</span><span class='line'>        curl \
</span><span class='line'>        openssl \
</span><span class='line'>        unzip&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ENV DOCKER_BUCKET get.docker.com
</span><span class='line'>ENV DOCKER_VERSION 1.13.0
</span><span class='line'>ENV DOCKER_SHA256 fc194bb95640b1396283e5b23b5ff9d1b69a5e418b5b3d774f303a7642162ad6&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;RUN set -x \
</span><span class='line'>    &amp;&amp; curl -fSL &ldquo;&lt;a href="https://$"&gt;https://$&lt;/a&gt;{DOCKER_BUCKET}/builds/Linux/x86_64/docker-${DOCKER_VERSION}.tgz&rdquo; -o docker.tgz \
</span><span class='line'>    &amp;&amp; echo &ldquo;${DOCKER_SHA256} &lt;em&gt;docker.tgz&rdquo; | sha256sum -c - \
</span><span class='line'>    &amp;&amp; tar -xzvf docker.tgz \
</span><span class='line'>    &amp;&amp; mv docker/&lt;/em&gt; /usr/local/bin/ \
</span><span class='line'>    &amp;&amp; rmdir docker \
</span><span class='line'>    &amp;&amp; rm docker.tgz \
</span><span class='line'>    &amp;&amp; docker -v&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;install aws&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;RUN apt-get install -y python-pip groff-base
</span><span class='line'>RUN pip install awscli&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;install packer&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;RUN curl -OL#\
</span><span class='line'> &lt;a href="https://releases.hashicorp.com/packer/0.12.2/packer_0.12.2_linux_amd64.zip"&gt;https://releases.hashicorp.com/packer/0.12.2/packer_0.12.2_linux_amd64.zip&lt;/a&gt; &amp;&amp;\
</span><span class='line'> unzip packer_0.12.2_linux_amd64.zip -d /usr/local/bin/&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;copy file&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;WORKDIR /build
</span><span class='line'>COPY infrastructure infrastructure
</span><span class='line'>COPY pipeline/test/env_packet/packet4testEnv.sh /usr/local/bin&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ENTRYPOINT [&ldquo;packet4testEnv.sh&rdquo;]
</span><span class='line'>&lt;code&gt;
</span><span class='line'>然后添加打包脚本
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-build packet environment&rdquo;
</span><span class='line'>docker build -t packer_aws_env -f ./pipeline/test/env_packet/Dockerfile .
</span><span class='line'>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-tag image&rdquo;
</span><span class='line'>docker tag packer_aws_env $ECR_REPOSITORY:sf-test-packet
</span><span class='line'>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-aws login&rdquo;
</span><span class='line'>aws ecr get-login | bash
</span><span class='line'>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-push to ecr&rdquo;
</span><span class='line'>docker push $ECR_REPOSITORY:sf-test-packet</span></code></pre></td></tr></table></div></figure></p>

<h3>结合packer与ecr构建并上传镜像</h3>

<p>外层docker环境
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-pull docker image from ecr&rdquo;
</span><span class='line'>aws ecr get-login | bash
</span><span class='line'>docker pull $ECR_REPOSITORY:sf-test-packet&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;echo &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-run packer in docker and packet for test environment&rdquo;
</span><span class='line'>docker run &ndash;rm \
</span><span class='line'> -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
</span><span class='line'> -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
</span><span class='line'> -e AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION \
</span><span class='line'> -e ECR_LOGIN_SERVER=$ECR_LOGIN_SERVER \
</span><span class='line'> -e ECR_REPOSITORY=$ECR_REPOSITORY \
</span><span class='line'> $ECR_REPOSITORY:sf-test-packet&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;内层docker环境
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&ldquo;run_command&rdquo;: [&ldquo;-d&rdquo;, &ldquo;-i&rdquo;, &ldquo;-t&rdquo;, &ldquo;-v&rdquo;, &ldquo;/var/run/docker.sock:/var/run/docker.sock&rdquo;, &ldquo;&rdquo;, &ldquo;/bin/bash&rdquo;]</span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH登录原理简介]]></title>
    <link href="http://xbox1994.github.io/blog/2017/01/16/sshdeng-lu-yuan-li-jian-jie/"/>
    <updated>2017-01-16T22:19:46+08:00</updated>
    <id>http://xbox1994.github.io/blog/2017/01/16/sshdeng-lu-yuan-li-jian-jie</id>
    <content type="html"><![CDATA[<p>每次都用SSH登录,却没有关心过其中的原理,实在没脸用SSH</p>

<!--more-->


<h2>什么是SSH?</h2>

<p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。</p>

<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p>

<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p>

<p>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。</p>

<p>转自<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p>

<h2>从用到懂</h2>

<h3>用</h3>

<p>  Secure Shell is a protocol used to securely log onto remote systems.
  It can be used for logging or executing commands on a remote server.</p>

<ul>
<li><p>Connect to a remote server:<br/>
ssh username@remote_host</p></li>
<li><p>Connect to a remote server with a specific identity (private key):<br/>
ssh -i path/to/key_file username@remote_host</p></li>
<li><p>Connect to a remote server using a specific port:<br/>
ssh username@remote_host -p 2222</p></li>
<li><p>Run a command on a remote server:<br/>
ssh remote_host command -with -flags</p></li>
<li><p>SSH tunneling: Dynamic port forwarding (SOCKS proxy on localhost:9999):<br/>
ssh -D 9999 -C username@remote_host</p></li>
<li><p>SSH tunneling: Forward a specific port (localhost:9999 to slashdot.org:80):<br/>
man ssh_config</p></li>
<li><p>Enable the option to forward the authentication information to the remote machine (see man ssh_config for available options):<br/>
ssh -o &ldquo;ForwardAgent=yes&rdquo; username@remote_host</p></li>
</ul>


<p>引用自tldr(与fuck一样是一辈子都要用的,实在是太好用了)</p>

<p>具体配置SSH客户端的文件在
  - ~/.ssh/config
  - /etc/ssh/ssh_config</p>

<p>ssh_config &ndash; OpenSSH SSH client configuration files,与SSH连接的配置项,如超时控制,连接策略</p>

<h3>懂</h3>

<p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p>

<p>SSH公钥登录:<br/>
1.客户端将自己的公钥提前保存到服务端<br/>
2.服务端用客户端的公钥加密一个256位的随机字符串，发送给客户端<br/>
3.客户端接收后用客户端的私钥解密，然后将这个字符串和会话标识符合并在一起，对结果应用MD5散列函数并把散列值返回给服务器<br/>
4.服务器将之前产生的随机字符串与会话标示符进行相同的MD5散列函数与客户端产生的散列值对比</p>

<p>SSH私钥登录:
ssh -i 使用服务器已经保存的公钥对应的私钥,相当于使用他人身份登录,过程与公钥登录相同,只是将默认使用的~/.ssh/id_rsa替换成指定私钥</p>

<p>SSH密码登录:<br/>
1.服务器把自己的公钥发给客户端，ssh会将服务器的公钥存放在客户端的~/.ssh/known_hosts文件下<br/>
2.客户端会根据服务器给它发的公钥将密码进行加密，加密好之后返回给服务器<br/>
3.服务器用自己的私钥解密，对比密码是否正确<br/>
如果服务器改变了自己的公钥，客户端想要登录时必须删除自己~/.ssh/known_hosts文件下的旧内容，重新获取服务器新的公钥。只要你知道服务器上的用户和密码，就可以成功登录到远程服务器上。</p>

<h3>安全威胁</h3>

<p>如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），在客户端与服务端中间伪装成客户端与服务端,用伪造的公钥,获取用户的登录密码(中间人攻击 <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">https://en.wikipedia.org/wiki/Man-in-the-middle_attack</a> )。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了.</p>

<p>对于这个问题,SSH有自己的一套简易防范措施:</p>

<p>第一次连接时会显示公钥指纹，跟对方确认后连接，一般是在官方网站上有对应指纹提供给用户验证,当选择yes,就会将该主机的公钥追加到该主机本地文件~/.ssh/known_hosts中。当再次连接该主机时，会比对这次连接的主机公钥与之前保存的公钥是否一致</p>

<p>如果因为某种原因（服务器系统重装，服务器间IP地址交换，DHCP，虚拟机重建，中间人劫持），该IP地址的公钥改变了，当使用 SSH 连接的时候，会报错：Host key verification failed.</p>

<p>如果自己可以确认对方域名是绝对安全可靠的,即使IP变动也是正常的话,那么可以使用如下方式省去验证步骤:<br/>
只需要修改 /etc/ssh/ssh_config 文件，包含下列语句：<br/>
Host *<br/>
 StrictHostKeyChecking no<br/>
或者在 ssh 命令行中用 -o 参数<br/>
ssh  -o StrictHostKeyChecking=no  192.168.0.110</p>

<p>如果设置了无口令 SSH 登录（即通过客户端公钥认证），就可以直接连接到远程主机。这是基于 SSH 协议的自动化任务常用的手段。</p>

<p>部分引用自:<a href="http://www.worldhello.net/2010/04/08/1026.html">http://www.worldhello.net/2010/04/08/1026.html</a></p>
]]></content>
  </entry>
  
</feed>
