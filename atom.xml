<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tianyi's blog]]></title>
  <link href="http://xbox1994.github.io/atom.xml" rel="self"/>
  <link href="http://xbox1994.github.io/"/>
  <updated>2017-02-12T13:06:12+08:00</updated>
  <id>http://xbox1994.github.io/</id>
  <author>
    <name><![CDATA[Tianyi Wang]]></name>
    <email><![CDATA[tywang@thoughtworks.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Docker Port与iptables]]></title>
    <link href="http://xbox1994.github.io/blog/2017/02/04/docker-portyu-iptables/"/>
    <updated>2017-02-04T16:57:08+08:00</updated>
    <id>http://xbox1994.github.io/blog/2017/02/04/docker-portyu-iptables</id>
    <content type="html"><![CDATA[<p>一个请求是如何从实体机传递到我们的应用的</p>

<p>iptables -> docker deamon -> docker bridge network -> docker container -> app</p>

<!--more-->


<h2>从iptables开始</h2>

<p>参考:<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Security_Guide/s1-firewall-ipt-fwd.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Security_Guide/s1-firewall-ipt-fwd.html</a></p>

<p>维基百科:iptables，一个运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的流动与转送。</p>

<p>因为公网IP的稀有与昂贵,公司一般只有一个公网IP,使用局域网与私有IP是访问公网资源的常用方式.防火墙与路由器可以将请求转发到内网机器上,也可以将传入路由到对应内网节点.这样的转发很危险,特别是攻击者伪装成内网节点.为了防止这种情况，iptables提供了可以实现的路由和转发策略，以防止网络资源的异常使用。</p>

<h4>iptables的FORWARD策略</h4>

<p>控制经过本节点的数据包路由的位置,例如转发到所有节点</p>

<p>如果这样设置,在这个防火墙之后的所有节点都可以接收到数据包,相当于创建了一个路由规则,发送到这个路由的数据包都可以达到数据包内包含的预期节点,且都通过eth1设备</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>iptables -A FORWARD -i eth1 -j ACCEPT
</span><span class='line'>iptables -A FORWARD -o eth1 -j ACCEPT</span></code></pre></td></tr></table></div></figure>


<p>此时内网节点还不能正常访问外网,需要将内网IP伪装成路由IP来访问外网资源</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span></code></pre></td></tr></table></div></figure>


<p>如果你想让一个内网节点成为外部可用的服务器,使用DNAT转发策略,将外部请求转发到改内网节点,Docker就是使用这个策略将请求转发到对应container中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to 172.31.0.23:80</span></code></pre></td></tr></table></div></figure>


<h2>iptables结合docker deamon转发</h2>

<p>参考:<a href="https://wiki.archlinux.org/index.php/Network_bridge_">https://wiki.archlinux.org/index.php/Network_bridge_</a>(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) &lt;Docker进阶与实战></p>

<h4>iptables -> docker deamon</h4>

<p>Docker deamon在启动container时会在主机上采用iptables的DNAT策略,将iptables接受到的请求转发给改container所属的内网节点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@ip-172-31-18-147:/home/ubuntu# docker run -itd -p 80:80 nginx
</span><span class='line'>
</span><span class='line'>root@ip-172-31-18-147:/home/ubuntu# docker ps
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES
</span><span class='line'>660b89af3737        nginx               "nginx -g 'daemon ..."   3 seconds ago       Up 2 seconds        0.0.0.0:80-&gt;80/tcp, 443/tcp   amazing_dijkstra
</span><span class='line'>r
</span><span class='line'>
</span><span class='line'>root@ip-172-31-18-147:/home/ubuntu# iptables -L
</span><span class='line'>Chain FORWARD (policy DROP)
</span><span class='line'>target     prot opt source               destination
</span><span class='line'>DOCKER     all  --  anywhere             anywhere
</span><span class='line'>Chain DOCKER (1 references)
</span><span class='line'>target     prot opt source               destination
</span><span class='line'>ACCEPT     tcp  --  anywhere             172.17.0.2           tcp dpt:http
</span></code></pre></td></tr></table></div></figure>


<h4>docker deamon -> docker bridge network</h4>

<p>Docker deamon启动时会在主机创建一个Linux网桥(网桥:网桥是一种软件配置，用于连结两个或更多个不同网段。网桥的行为就像是一台虚拟的网络交换机，工作于透明模式（即其他机器不必关注网桥的存在与否）。任意的真实物理设备（例如 eth0）和虚拟设备（例如 tap0）都可以连接到网桥。)(默认为docker0).</p>

<p>容器启动时会创建一对veth pair,docker将一端挂在docker0网桥上,另一端放到容器的Network Namespace内,从而实现容器与主机通信的目的.
<img src="http://xbox1994.github.io/images/blog/docker_bridge_network.png" title="image" alt="images"></p>

<h4>docker bridge network -> docker container</h4>

<p>当前没有容器运行,网桥上没有网络接口,但默认分配了172.17.0.1/16的子网</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@ip-172-31-18-147:/home/ubuntu# ip addr show docker0
</span><span class='line'>5: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default
</span><span class='line'>    link/ether 02:42:51:23:1f:10 brd ff:ff:ff:ff:ff:ff
</span><span class='line'>    inet 172.17.0.1/16 scope global docker0
</span><span class='line'>       valid_lft forever preferred_lft forever
</span><span class='line'>    inet6 fe80::42:51ff:fe23:1f10/64 scope link
</span><span class='line'>       valid_lft forever preferred_lft forever</span></code></pre></td></tr></table></div></figure>


<p>然后启动一个container测试,container会自动加入到该子网中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>root@ip-172-31-18-147:/home/ubuntu# docker run -it ubuntu:14.04
</span><span class='line'>root@82c955281fdb:/# ip addr show
</span><span class='line'>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default
</span><span class='line'>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span><span class='line'>    inet 127.0.0.1/8 scope host lo
</span><span class='line'>       valid_lft forever preferred_lft forever
</span><span class='line'>    inet6 ::1/128 scope host
</span><span class='line'>       valid_lft forever preferred_lft forever
</span><span class='line'>931: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
</span><span class='line'>    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
</span><span class='line'>    inet 172.17.0.2/16 scope global eth0
</span><span class='line'>       valid_lft forever preferred_lft forever
</span><span class='line'>    inet6 fe80::42:acff:fe11:2/64 scope link
</span><span class='line'>       valid_lft forever preferred_lft forever</span></code></pre></td></tr></table></div></figure>


<p><em><strong>综上所述,Docker会为我们创建一个iptables转发规则,将从外界接收到的请求转发到Docker在启动container时创建的子网中的对应节点</strong></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker in Docker]]></title>
    <link href="http://xbox1994.github.io/blog/2017/01/29/docker-in-docker/"/>
    <updated>2017-01-29T14:52:48+08:00</updated>
    <id>http://xbox1994.github.io/blog/2017/01/29/docker-in-docker</id>
    <content type="html"><![CDATA[<p>我想过一个非常有意思的东西:在docker里面运行docker,然后在docker里运行的docker中再运行一个docker,接着在docker里运行的docker里运行的docker中再开一个docker..接着迭代100次会发生什么</p>

<!--more-->


<p>结合这篇文章:<a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/</a>
以及自己的经验与实践总结出下文.</p>

<p>&ldquo;If you want the short solution without the details, just scroll to the bottom of this article. ☺&rdquo;</p>

<h2>Bad</h2>

<p>如果你在docker中运行了docker,会导致一下问题:</p>

<p>1.当你使用-privileged的时候会导致一个在内部docker与外部docker之间的安全配置无法合并的冲突,是关于LSM (Linux Security Modules)的</p>

<p>2.外部docker运行在正常的文件系统中,但内部docker运行在写时拷贝的文件系统,会直接导致无法运行或者因为命名空间的问题影响其他container</p>

<h2>Solution</h2>

<p>其实基本上来说是不存在需要在docker中跑docker这种需求的,你想要的只是在docker中启动一个docker的container来运行你的程序,并不关心这个container在哪个docker进程中.下面提供一种方式可以让你在docker内部调用这个docker程序开启新的container帮助你完成工作:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker run -v /var/run/docker.sock:/var/run/docker.sock ...</span></code></pre></td></tr></table></div></figure>


<p>这样你程序所在的container中已经有权限访问docker的socket,因此可以用docker run启动同胞兄弟而不是子容器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/ # docker ps
</span><span class='line'>➜  ~ docker run -v /var/run/docker.sock:/var/run/docker.sock -ti docker
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
</span><span class='line'>8c84704e890e        docker              "docker-entrypoint..."   2 seconds ago       Up 1 second                             brave_lichterman
</span><span class='line'>/ # docker run -v /var/run/docker.sock:/var/run/docker.sock -ti docker
</span><span class='line'>/ # docker ps
</span><span class='line'>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
</span><span class='line'>34dcf16326c2        docker              "docker-entrypoint..."   3 seconds ago       Up 2 seconds                            inspiring_mcnulty
</span><span class='line'>8c84704e890e        docker              "docker-entrypoint..."   37 seconds ago      Up 36 seconds                           brave_lichterman</span></code></pre></td></tr></table></div></figure>


<h2>Practice</h2>

<p>使用上述Solution打包一个docker镜像</p>

<h3>构建打包镜像的环境</h3>

<p>网上实在没有找到包含docker+aws+packer的ubuntu docker镜像,以下是dockerfile</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM ubuntu:14.04
</span><span class='line'>
</span><span class='line'># install docker
</span><span class='line'>RUN apt-get update \
</span><span class='line'>    && apt-get -y install ca-certificates \
</span><span class='line'>      curl \
</span><span class='line'>      openssl \
</span><span class='line'>      unzip
</span><span class='line'>
</span><span class='line'>ENV DOCKER_BUCKET get.docker.com
</span><span class='line'>ENV DOCKER_VERSION 1.13.0
</span><span class='line'>ENV DOCKER_SHA256 fc194bb95640b1396283e5b23b5ff9d1b69a5e418b5b3d774f303a7642162ad6
</span><span class='line'>
</span><span class='line'>RUN set -x \
</span><span class='line'>  && curl -fSL "https://${DOCKER_BUCKET}/builds/Linux/x86_64/docker-${DOCKER_VERSION}.tgz" -o docker.tgz \
</span><span class='line'>  && echo "${DOCKER_SHA256} *docker.tgz" | sha256sum -c - \
</span><span class='line'>  && tar -xzvf docker.tgz \
</span><span class='line'>  && mv docker/* /usr/local/bin/ \
</span><span class='line'>  && rmdir docker \
</span><span class='line'>  && rm docker.tgz \
</span><span class='line'>  && docker -v
</span><span class='line'>
</span><span class='line'># install aws
</span><span class='line'>RUN apt-get install -y python-pip groff-base
</span><span class='line'>RUN pip install awscli
</span><span class='line'>
</span><span class='line'># install packer
</span><span class='line'>RUN curl -OL#\
</span><span class='line'> https://releases.hashicorp.com/packer/0.12.2/packer_0.12.2_linux_amd64.zip &&\
</span><span class='line'> unzip packer_0.12.2_linux_amd64.zip -d /usr/local/bin/
</span><span class='line'>
</span><span class='line'># copy file
</span><span class='line'>WORKDIR /build
</span><span class='line'>COPY infrastructure infrastructure
</span><span class='line'>COPY pipeline/test/env_packet/packet4testEnv.sh /usr/local/bin
</span><span class='line'>
</span><span class='line'>ENTRYPOINT ["packet4testEnv.sh"]</span></code></pre></td></tr></table></div></figure>


<p>然后添加打包脚本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo "----------------------------------build packet environment"
</span><span class='line'>docker build -t packer_aws_env -f ./pipeline/test/env_packet/Dockerfile .
</span><span class='line'>echo "----------------------------------tag image"
</span><span class='line'>docker tag packer_aws_env $ECR_REPOSITORY:sf-test-packet
</span><span class='line'>echo "----------------------------------aws login"
</span><span class='line'>aws ecr get-login | bash
</span><span class='line'>echo "----------------------------------push to ecr"
</span><span class='line'>docker push $ECR_REPOSITORY:sf-test-packet</span></code></pre></td></tr></table></div></figure>


<h3>结合packer与ecr构建并上传镜像</h3>

<p>外层docker环境</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo "----------------------------------pull docker image from ecr"
</span><span class='line'>aws ecr get-login | bash
</span><span class='line'>docker pull $ECR_REPOSITORY:sf-test-packet
</span><span class='line'>
</span><span class='line'>echo "----------------------------------run packer in docker and packet for test environment"
</span><span class='line'>docker run --rm \
</span><span class='line'> -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
</span><span class='line'> -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
</span><span class='line'> -e AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION \
</span><span class='line'> -e ECR_LOGIN_SERVER=$ECR_LOGIN_SERVER \
</span><span class='line'> -e ECR_REPOSITORY=$ECR_REPOSITORY \
</span><span class='line'> $ECR_REPOSITORY:sf-test-packet
</span></code></pre></td></tr></table></div></figure>


<p>内层docker环境</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"run_command": ["-d", "-i", "-t", "-v", "/var/run/docker.sock:/var/run/docker.sock", "", "/bin/bash"]</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH登录原理简介]]></title>
    <link href="http://xbox1994.github.io/blog/2017/01/16/sshdeng-lu-yuan-li-jian-jie/"/>
    <updated>2017-01-16T22:19:46+08:00</updated>
    <id>http://xbox1994.github.io/blog/2017/01/16/sshdeng-lu-yuan-li-jian-jie</id>
    <content type="html"><![CDATA[<p>每次都用SSH登录,却没有关心过其中的原理,实在没脸用SSH</p>

<!--more-->


<h2>什么是SSH?</h2>

<p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。</p>

<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p>

<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p>

<p>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。</p>

<p>转自<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p>

<h2>从用到懂</h2>

<h3>用</h3>

<p>  Secure Shell is a protocol used to securely log onto remote systems.
  It can be used for logging or executing commands on a remote server.</p>

<ul>
<li><p>Connect to a remote server:<br/>
ssh username@remote_host</p></li>
<li><p>Connect to a remote server with a specific identity (private key):<br/>
ssh -i path/to/key_file username@remote_host</p></li>
<li><p>Connect to a remote server using a specific port:<br/>
ssh username@remote_host -p 2222</p></li>
<li><p>Run a command on a remote server:<br/>
ssh remote_host command -with -flags</p></li>
<li><p>SSH tunneling: Dynamic port forwarding (SOCKS proxy on localhost:9999):<br/>
ssh -D 9999 -C username@remote_host</p></li>
<li><p>SSH tunneling: Forward a specific port (localhost:9999 to slashdot.org:80):<br/>
man ssh_config</p></li>
<li><p>Enable the option to forward the authentication information to the remote machine (see man ssh_config for available options):<br/>
ssh -o &ldquo;ForwardAgent=yes&rdquo; username@remote_host</p></li>
</ul>


<p>引用自tldr(与fuck一样是一辈子都要用的,实在是太好用了)</p>

<p>具体配置SSH客户端的文件在
  - ~/.ssh/config
  - /etc/ssh/ssh_config</p>

<p>ssh_config &ndash; OpenSSH SSH client configuration files,与SSH连接的配置项,如超时控制,连接策略</p>

<h3>懂</h3>

<p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p>

<p>SSH公钥登录:<br/>
1.客户端将自己的公钥提前保存到服务端<br/>
2.服务端用客户端的公钥加密一个256位的随机字符串，发送给客户端<br/>
3.客户端接收后用客户端的私钥解密，然后将这个字符串和会话标识符合并在一起，对结果应用MD5散列函数并把散列值返回给服务器<br/>
4.服务器将之前产生的随机字符串与会话标示符进行相同的MD5散列函数与客户端产生的散列值对比</p>

<p>SSH私钥登录:
ssh -i 使用服务器已经保存的公钥对应的私钥,相当于使用他人身份登录,过程与公钥登录相同,只是将默认使用的~/.ssh/id_rsa替换成指定私钥</p>

<p>SSH密码登录:<br/>
1.服务器把自己的公钥发给客户端，ssh会将服务器的公钥存放在客户端的~/.ssh/known_hosts文件下<br/>
2.客户端会根据服务器给它发的公钥将密码进行加密，加密好之后返回给服务器<br/>
3.服务器用自己的私钥解密，对比密码是否正确<br/>
如果服务器改变了自己的公钥，客户端想要登录时必须删除自己~/.ssh/known_hosts文件下的旧内容，重新获取服务器新的公钥。只要你知道服务器上的用户和密码，就可以成功登录到远程服务器上。</p>

<h3>安全威胁</h3>

<p>如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），在客户端与服务端中间伪装成客户端与服务端,用伪造的公钥,获取用户的登录密码(中间人攻击 <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">https://en.wikipedia.org/wiki/Man-in-the-middle_attack</a> )。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了.</p>

<p>对于这个问题,SSH有自己的一套简易防范措施:</p>

<p>第一次连接时会显示公钥指纹，跟对方确认后连接，一般是在官方网站上有对应指纹提供给用户验证,当选择yes,就会将该主机的公钥追加到该主机本地文件~/.ssh/known_hosts中。当再次连接该主机时，会比对这次连接的主机公钥与之前保存的公钥是否一致</p>

<p>如果因为某种原因（服务器系统重装，服务器间IP地址交换，DHCP，虚拟机重建，中间人劫持），该IP地址的公钥改变了，当使用 SSH 连接的时候，会报错：Host key verification failed.</p>

<p>如果自己可以确认对方域名是绝对安全可靠的,即使IP变动也是正常的话,那么可以使用如下方式省去验证步骤:<br/>
只需要修改 /etc/ssh/ssh_config 文件，包含下列语句：<br/>
Host *<br/>
 StrictHostKeyChecking no<br/>
或者在 ssh 命令行中用 -o 参数<br/>
ssh  -o StrictHostKeyChecking=no  192.168.0.110</p>

<p>如果设置了无口令 SSH 登录（即通过客户端公钥认证），就可以直接连接到远程主机。这是基于 SSH 协议的自动化任务常用的手段。</p>

<p>部分引用自:<a href="http://www.worldhello.net/2010/04/08/1026.html">http://www.worldhello.net/2010/04/08/1026.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一次性能优化探索-Nginx有什么用]]></title>
    <link href="http://xbox1994.github.io/blog/2017/01/08/mou-ci-you-hua-shi-jian-nginxshi-na-lai-gan-shi-yao-de/"/>
    <updated>2017-01-08T18:32:58+08:00</updated>
    <id>http://xbox1994.github.io/blog/2017/01/08/mou-ci-you-hua-shi-jian-nginxshi-na-lai-gan-shi-yao-de</id>
    <content type="html"><![CDATA[<p>&ldquo;这张卡马上做完了,赶紧desk check,我们先把测试环境准备好&rdquo;.我高高兴兴地跟洲说,随手修改了一下配置文件中的微服务访问路径,然后重启服务器,一切看起来那么的一帆风顺.<br/>
&ldquo;好的,页面开始Loading啦&rdquo;&hellip;10分钟之后&hellip;&ldquo;我受不了了&rdquo;</p>

<!--more-->


<h2>问题</h2>

<p>1.本地环境开启的应用访问EC2上的某微服务速度慢,但在EC2环境开启的应用访问该微服务速度快.</p>

<p>2.本地环境加载某一个页面的过程中刷新,会很长时间内没有回应</p>

<h2>区别</h2>

<p>本地应用环境与EC2真实环境局别如下:<br/>
1.本地与EC2其他微服务的连接是外网通信,运行应用的EC2实例与其他微服务的连接是内网通信<br/>
2.本地Web Server使用的是Thin,EC2服务器使用的是Unicorn+Nginx</p>

<h2>猜测</h2>

<p>首先我们觉得是网络环境的问题,因为我们同时发现上午网速确实比下午网速快,所以忍耐了很长时间没有下功夫在这方面,直到最近洲回来了,对这个访问速度感到很是愤怒.
在连接上VPN之后,发现速度什么的都不是问题,但是加载数据量较大的资源时还是比较慢</p>

<h2>研究</h2>

<p>问题1:</p>

<p>所以开始研究第二个区别,本地测试三种环境如下图:<br/>
1)Thin<br/>
<img src="http://xbox1994.github.io/images/blog/home_thin.png" title="image" alt="images">
2)Unicorn<br/>
<img src="http://xbox1994.github.io/images/blog/home_unicorn.png" title="image" alt="images">
3)Unicorn+Nginx
<img src="http://xbox1994.github.io/images/blog/home_nginx+unicorn.png" title="image" alt="images"></p>

<p>可以看出:<br/>
1.对于Thin和Unicorn服务器来说,资源不论大小,他们的耗时是基本相同的.<br/>
2.拿有Nginx的Unicorn服务器与没有Nginx的Unicorn服务器来说,数据量小的资源会稍慢一些,但数据量大的资源速度提升明显.<br/>
3.Nginx将数据进行大幅度压缩,导致Size远小于Content</p>

<p>问题2:</p>

<p>经过测试,1)和2)都存在这个问题,但3)不存在,很明显是默认配置的服务器无法同时处理多个请求,可以通过
1.&ndash;threaded开启Thin多线程模式<br/>
2.Nginx与多进程模式Unicorn的配合<br/>
均可以使得不用等待上一个请求结束而直接请求另一个服务器并立马得到回应.</p>

<h2>服务器通信级别的原因</h2>

<h3>Nginx对请求的压缩处理</h3>

<p>具体解释与参数配置在<br/>
<a href="https://www.nginx.com/resources/admin-guide/compression-and-decompression/">https://www.nginx.com/resources/admin-guide/compression-and-decompression/</a></p>

<p>gzip是默认配置在nginx.conf内的,所以默认开启,如果不对数据量要求特别精细的话,默认配置完全可以满足基本需求</p>

<p>上图的2.5MB大文件显然被压缩成几百K的小文件在网络上进行传输,大大减轻了应用的网络负载</p>

<h3>Nginx对请求的合并处理</h3>

<p>先回顾一下Nginx反向代理的原理:正向代理是将自己要访问的资源告诉Proxy,让Proxy帮你拿到数据返回给你,Proxy服务于Client,常用于翻墙和跨权限操作;反向代理也是将自己要访问的资源告诉Proxy,让Proxy帮你拿到数据返回给你,但是Proxy服务于Server,它会将请求接受完毕之后发送给某一合适的Server,常用于负载均衡.</p>

<p><img src="http://xbox1994.github.io/images/blog/nginx_priciple.png" title="image" alt="images"></p>

<p><strong><em>Proxy统一接收Client请求，接收完毕后才发给Server，提高Server处理效率</em></strong></p>

<p>Using a reverse proxy server frees the application server from having to wait for users to interact with the web app and lets it concentrate on building pages for the reverse proxy server to send across the Internet<br/>
<a href="https://www.nginx.com/blog/10-tips-for-10x-application-performance/">https://www.nginx.com/blog/10-tips-for-10x-application-performance/</a></p>

<p>Nginx在其他方面也有好处,如直接返回静态文件,添加重定向与SSL证书,添加返回头,可参看这篇[NUS后台]</p>

<h3>少量请求+单机运行Nginx的坏处</h3>

<p>Nginx是负责接收/返回请求与转发/返回请求的,在这个过程中会涉及到资源的压缩处理,势必会拖慢请求处理速度并加重Nginx运行环境的负担;同时,在转发到Server和接受Server返回的资源的过程中是会进行TCP连接的,此段的开销会拖慢整体返回速度,所以可能会出现单个请求返回速度比不使用Nginx的速度慢.</p>

<p>但是,在高并发情况下,才是Nginx的用武之地.如果1台实例无法处理成千上万个请求,那么就用集群吧,Nginx帮你负载均衡并添加一道隐形的安全防火墙,记住,一定要把Nginx放到一台独立的实例上而不要与其他服务共存,否则反而会影响整体处理速度.</p>

<p>换句话说,使用Nginx的后台架构中的单个请求的处理速度可能会慢于不使用Nginx的后台架构,但在高并发环境下,不使用Nginx的后台可能会爆掉Out of memory..使用Nginx的后台依然坚挺,为了系统的稳定性与负载均衡,使用Nginx是非常明智的选择.</p>

<h2>代码级别的原因</h2>

<p>上面是针对已有代码进行的服务器通信阶段进行的分析,在代码内部实现,依然还有很多加快加载速度的方式,对于我们这个例子来说的话:<br/>
1.前台不应该加载2.5MB这样巨大的文件,除非万不得已.在前台做数据的展现即可,不需要先拿到全部数据后做数据的查询.<br/>
2.代码级别存在很多批处理请求,但发送的时候是单条发送,建议使用批量处理对应的API</p>

<h2>结论</h2>

<p>1.网络问题是影响本地加载速度最大的因素,本地网络暂时难以改变,不连接/连接VPN+添加防火墙规则解决.<br/>
2.代码层级可以做适当优化,解决大资源加载以及请求发送策略,将要解决.<br/>
3.对于页面重新加载速度过慢的问题,使用多线程配置解决,已经解决.<br/>
4.对于大资源加载问题,考虑使用Nginx压缩处理,grunt ddev已经解决.<br/>
5.对于以后可能出现的请求数量过多问题采用Nginx+Unicorn负载均衡,已经解决.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning How to Learn]]></title>
    <link href="http://xbox1994.github.io/blog/2016/12/31/learning-how-to-learn/"/>
    <updated>2016-12-31T18:05:30+08:00</updated>
    <id>http://xbox1994.github.io/blog/2016/12/31/learning-how-to-learn</id>
    <content type="html"><![CDATA[<p>在过去的很多年时间里,我很少,其他人也很少告诉我们自己该如何学习,而是告诉你时间是挤出来的,把时间花到学习上是唯一提高学习成绩的方法.</p>

<p>如果我能早一些看到<Learning how to learn>,或者说如果我能早一些意识到这一点,把其中的理论实践下去可能会以自己为例反驳上面的观点.</p>

<!--more-->


<p>我们时常听到一些感觉很矛盾的传说:某人特牛逼,学习总是名列前茅,还经常花时间去干别的事,如打篮球,玩游戏.我原来会觉得这种人肯定是天才,脑袋绝顶聪明那种,老师会告诉我们他是晚上熬夜用功.其实老师没有错,对绝大多数人来说,用功的自己比不用功的自己更强一些.
但是为什么就不能教一些学习的方法技巧给我们呢,一股脑将知识填给我们,不知道我们会因此忽略掉漏掉多少重要的东西,短暂的自习时间,没有机会让自己进入发散的思考模式.这是一个让我们自己花很大的代价去探索学习的路线的学习模式.</p>

<p>有两个大学老师给了我很深的印象,其中一个老师仅仅只是在四年中只会见上几面的实验课老师,他不会像其他老师用书本和例题对我们狂轰滥炸,而是用一种引导式的方法教会我们如何走向正确的解题方向</p>

<p><em><strong>然而现在开始学会学习,为时不晚</strong></em></p>

<p>一个月的时间将这门课过完一遍,一定要马上总结不然过一段时间就会如同失忆般问自己,&ldquo;我什么时候看过这个东西?&rdquo;</p>

<p>这是用Xmind画出来的在这门课中我觉得比较关键的知识和方法,红星标注的是具体学习方法
<img class="left" src="http://xbox1994.github.io/images/blog/learning_how_to_learn.png" width="1000" height="1000" title="image" alt="images">
这门课程从大脑工作原理开始,用生动形象的比喻和通俗易懂的语言结合现有神经学心理学研究成果告诉了一个可能的正确学习的方式.</p>

<p>了解到其中提到的几个学习方法或应试技巧(如番茄工作法,过度学习,交替学习,先难后易,Test List)其实对我们已经是很大的帮助了,剩下的只是自己去实践了.</p>

<h2>集中模式VS发散模式</h2>

<h3>集中模式</h3>

<p>运用已有知识进行习惯性的输出.就像Windows自带的三维弹球中的密集缓冲区一样,弹球在他们之间飞快的穿梭,但是仅限于缓冲区内部,一旦脱离密集缓冲区,弹球会失去约束力被重力引导到其他地区.<br/>
优点:已走过的老路无比通畅<br/>
缺点:难以突破习惯性思维</p>

<h3>发散模式</h3>

<p>思维不专注在某一细节,不局限于某一方向思考问题.三维弹球中的其他区域虽然没有密集缓冲区那样可以让弹球保持稳定的飞速运动,但一旦触发到某个机关,往往会触发到意向不到的情况.<br/>
优点:是很多创新,灵感,解决问题的新思路的来源<br/>
缺点:难以专注细节,无法考虑全面</p>

<h3>技巧:学会转换</h3>

<p>在爱迪生工作的休息间隙,他会拿着一个滚珠小憩一会,当他将要入睡的时候手会自觉松开,滚珠落地将他惊醒.<br/>
集中精力开始工作,发散思维得到联想,成千上万个灵感涌入爱迪生的脑袋.最简单的实践就是,集中精力工作之后将难题记住,午间休息时试图带入思考入睡.</p>

<h2>组块</h2>

<p>大脑中小而紧凑的信息包,每个组块相当于一小块记忆,组块越多是构造组块帝国的基石,但如何创造众多组块联系在一起的关系同样是非常重要的.如同用砖块砌墙,砖块重要,水泥与瓦工同样重要.</p>

<h3>如何组织信息包</h3>

<p>1.集中注意力
当我们试图get一个新知识时,集中注意力是废话一样的存在.
我的某高中老师讲过关于他的一个经历,当年他和一个成绩特别好的同学同桌时,每次他想上课找这个同桌唠唠嗑,该同桌都是一脸嫌弃并对他抛出了一个异常,然后他默默的掏出了自己的&hellip;自己玩去了</p>

<p>2.理解基本含义
这里涉及到学习的假象,自己以为这个基本含义我知道了,但是一到别人问你,一到考试的时候一脸懵逼,&ldquo;我记得我知道这个东西啊,怎么感觉又不是这个样子?&rdquo;.自信的小伙子,不要以为你真的学会了哦!<br/>
<em><strong>没有教会他人是绝对不能说自己完全掌握的哦</strong></em><br/>
Recall &amp;&amp; Self-test是发现假象的最好方式,用回顾所学知识和自测的方式来发现自己存在的问题.当你尝试过一次之后会立马发现,某些东西确实还没有掌握的那么清楚.当然加入学习小组帮助别人或者他人帮助自己学习也是非常好的方法,但不要变成了一个游戏小组</p>

<p>3.获取背景知识,得到应用场景
&ldquo;我会C/C++/R/Phthon/Java/Ruby/JS/Delphi/Shell语言,并且我会熟练使用它们&rdquo;.简历中如果有这句话看起来是非常耀眼.但是如果现在为我们自己的一个特定需求去挑选一个最合适的语言去开发,我们会如何选择?
就像工具箱你有几百个工具,但不知道什么时候应该使用哪一个,那么工具只会变成一堆破铜烂铁.</p>

<h2>学习的三大难题:假象 &amp;&amp; 遗忘 &amp;&amp; 拖延症</h2>

<h3>假象</h3>

<p>同上理解基本含义</p>

<h3>遗忘VS记忆</h3>

<p>工作记忆:有意识的处理事情时会调用的记忆区间,正常人大概可以同时关注4个工作记忆区间</p>

<p>长期记忆:工作记忆转化而来,比工作记忆稳定,但是依然需要间隔重复法来稳定记忆</p>

<p>我们在完成一件事情的时候我们的大脑只会在工作记忆区间寻觅需要的记忆,长期记忆会被调用到工作记忆区间协同工作.然而工作记忆非常不稳定,需要及时转化为长期记忆来长期储存.</p>

<p>下面是一些转化的技巧:
<strong><em>间隔重复法/保证正常休息/用线索构建记忆宫殿</em></strong></p>

<h3>拖延症</h3>

<p>原理:想学一个东西,但是由于某些原因,会产生一定的痛苦,没有办法坚持下去,然后就开始寻找可以令自己开心起来的东西,最后的结果是这个东西永远没有学会</p>

<p><strong><em>必杀技:番茄工作法 </em></strong><br/>
25分钟工作+5分钟奖励时间让你告别痛苦,专注过程.一切基于一个事实:一旦开始着手于你要完成的事,你就会发现其实并不是那么痛苦.</p>

<h2>鼓励师</h2>

<p>万万没有想到这门课里会出现一个鼓励师,给一个大大的赞!</p>

<h3>不需要羡慕天才</h3>

<p>1.智商天注定,现实已成定局,无法改变.<br/>
2.天才的优势导致了天才的劣势:能同时拥有很多工作记忆区块看起来什么都可以游刃有余,但是工作记忆锁住了思维,阻止了创新的思路.<br/>
3.蠢材的劣势构建了蠢材的优势:比天才少一些习惯性的思路,有可以轻松调取其他长期记忆的能力,从而多一些解决问题的思路,只要坚持努力下去就会有收获.<br/>
4.打开一扇窗的同时关了一道门.</p>

<h3>现实如此吗</h3>

<p>很遗憾,现实不是如此,世界的进步大部分来源于天才.詹姆斯·瓦特的多项蒸汽机关键技术.33岁任清华国学研究院导师的赵元任.莫扎特14岁时,在罗马的西斯廷小教堂听了一首经文歌的演唱后,就能凭记忆把它一个音一个音地默写出来.<br/>
现实有太多例子,送自己一个连接<a href="https://www.zhihu.com/question/34054445">https://www.zhihu.com/question/34054445</a></p>

<p>天才毕竟是少数,教育体系一定是要满足大多数的情况,因材施教很难实现,那我们就放任自己了吗?</p>

<h3>天才VS蠢材</h3>

<p><strong><em>天才足够堕落可以变得比蠢材更加蠢材,蠢材足够努力可以变得比天才更加天才.</em></strong></p>

<p>对的!一定有方法和技巧可以维护世界的平衡!<br/>
<em><strong>专练最难的部分可以提升相关天赋,多一种解决思路,多一些经验可以在下次决战的一瞬间秒杀天才</strong></em></p>

<h2>后记</h2>

<p>原理上写的并不多,因为原理比较容易理解,我更需要的是可以应用的学习方法与意识(在手旁放了一本&lt;代码整洁之道>发现我的代码真的变整洁了不少0.0).我总是喜欢在写一个东西的时候放上自己的评论,有点跑偏主题的意思,并且在最后一定要加上一个PS/后记.其实博客没那么多规定啦,毕竟这是属于我的地方,6点写到10点,是真的没感觉时间过的这么快.</p>

<p>对于我来说最大的问题是遗忘,所以间隔重复法对我来说应该效果很好.然而现在最大的问题是前端快要把我逼疯了QAQ.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你的名字。]]></title>
    <link href="http://xbox1994.github.io/blog/2016/12/25/ni-de-ming-zi-./"/>
    <updated>2016-12-25T15:57:48+08:00</updated>
    <id>http://xbox1994.github.io/blog/2016/12/25/ni-de-ming-zi-.</id>
    <content type="html"><![CDATA[<p>某夜,趟雨,迟到5分钟,坐下,观影,值了.</p>

<!--more-->


<p>这是我看过为数不多的电影之一,但这部电影的剧情是给我感触最深的.全剧可分为三个层次,每个层次内部有很强的主旨,但又有一条主线索贯穿其中.让人沉迷其中.</p>

<h2>若即若离</h2>

<p>若有若无的联系,情感是最为微妙的,非常容易迷住观众,引人入胜.</p>

<p>梦中交换身体,邂逅彼此,过着梦想的和从来没有过的生活,用文字约束着交流着.</p>

<p>&ldquo;姐姐你什么时候开始这么喜欢摸自己的胸啊.&rdquo;,&ldquo;你打太多份工了啊.&rdquo;&ldquo;还不是因为你乱花钱啊.&rdquo; 非常多有趣的细节让观众乐在其中.但令我印象最为深刻的还是两人之间从若有若无的联系到试图寻找对方的时刻,因为此时,两人已经无法分离.</p>

<h2>命中注定&amp;&amp;握在手里</h2>

<p>陨石掉落,再也见不到三叶了,看似一切都是命中注定,但是还好这是在电影中,一切都可以重新开始.让泷喝下那放了三年的口嚼酒,随后注定的是一场拯救.</p>

<p>人总是在寻找某个人,人总是在等待某个人,这样便产生了希望.泷一直在寻找三叶,拼了命的要救三叶,虽然他们一次都没有真正见过面,虽然三叶已经过世,但是命中注定是他们会相见的.</p>

<p>你可以说这就是剧本,剧本里的一切都是那么美好,即使出现跌宕起伏的情节也是为了吸人眼球.但是今天我发现一件很现实的事情,有个词叫做希望,就和今天过圣诞节一样,我们通常不会特别关注它的来龙去脉是如何的,而是它能给我们带来我们憧憬的美好,对爱人的眷念,只要不是狗血到不成样子的剧本或是有一些坏名声的节日,是很容易接受的.</p>

<h2>最怕做过的一切都是不值得的</h2>

<p>&ldquo;我好像在哪儿见过你&rdquo;,在观众都为最后一幕的擦肩而过感到心急时,泷终于说出了这句话,三叶泪流满面,&ldquo;我也是&rdquo;.这一瞬间是一个极致的泪点,以前经历过的简单而纯粹但又若即若离的爱情终于如愿以偿.但是,我好怕三叶没有被救回,好怕他们最后没有相见,好怕泷犹豫不决,好怕一切都是不值得的.</p>

<p>&ldquo;我好像在哪儿见过你&rdquo;,台词有写到,歌词有唱到,平时有说到.万一没有认出来呢,&ldquo;我好像是在哪里见过你,但是想不起来了,可能是上辈子或者梦中见到过吧&rdquo;.让我们相信"人世间所有的相遇都是久别重逢"也许是最有正能量的信念,能让我们珍惜眼前人.</p>

<p>但是如果真的没有认出来呢?那么做过的一切都是不值得吗? &ldquo;我喜欢你&rdquo;&ldquo;笨蛋你这样我怎么知道你叫什么啊(然而我差不多知道了)&rdquo;</p>

<h2>PS</h2>

<p>如果在一些字词中加入某种联系之后,产生羁绊,一切都变得美好了起来:<br/>
某个命中注定的夜晚,趟着淅淅沥沥的小雨,赶到了我的座位上,虽然迟到了5分钟,但看完发现然而并没有什么影响,看完了这部让我很有感触的电影,想到了遇到过的人与事,这部电影在情感细节方面抓的很过分,但这样刚好是我想要的.</p>

<p>&ldquo;这电影怎么这么乱,我就记得他们一直在跑啊跑啊跑啊的&rdquo;,&ldquo;算了吧,你这小伙子这智商完全跟我们不在一个频道上&rdquo;.下电梯时在人群中听到这番闲聊.但是,有什么问题呢?跑,是真的可以概括这部大作.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NUS后台]]></title>
    <link href="http://xbox1994.github.io/blog/2016/12/18/nusde-hou-tai/"/>
    <updated>2016-12-18T16:12:24+08:00</updated>
    <id>http://xbox1994.github.io/blog/2016/12/18/nusde-hou-tai</id>
    <content type="html"><![CDATA[<p>Nginx Unicorn Sinatra<br/>
研究一个后台架构,客户端发送的请求最开始是由是Nginx接收的,随后反向代理发送给Unicorn服务器的一个线程,接下来是Sinatra框架和Rack负责处理</p>

<!--more-->


<h3>Nginx</h3>

<p>是一个高性能的HTTP和反向代理服务器</p>

<p>根据以下文件你可以发现在SF中我们是如何使用nginx的
infrastructure/ansible/roles.add_app_to_nginx/files/sales_refresh_app_nginx_config</p>

<pre><code>server {
    #监听端口号
    listen 80;
    #会根据收到的HOST来匹配哪一个server，这样随便写没有匹配到的，那么第一个就是默认的
    server_name _;
    #重定向http请求为https
    return 301 https://$http_host$request_uri;
}

upstream unicorn_server {
    #IPC方式与unicorn通信，unicorn.rb
    server unix:/usr/share/nginx/sales_refresh_app/tmp/sockets/unicorn.sock
    #0让nginx反复重试后端即使超时，配合下面的unicorn配置文件使用
    fail_timeout=0;
}

server {
    listen 443;
    server_name _;
    #可直接访问静态文件
    root /usr/share/nginx/sales_refresh_app/public;
    ssl on;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_certificate /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;
    location / {
    #先查找是否有可以直接访问的文件，然后再去访问app
    try_files $uri @app;
    }
    location @app {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    # pass to the upstream unicorn server mentioned above
    proxy_pass http://unicorn_server;
    }
}
</code></pre>

<p>总结：在本机上同时使用nginx和unicorn，所以用到了反向代理，没有用到负载均衡。只提供https协议访问。静态文件加速访问。配置与unicorn的关系。</p>

<h3>Unicorn</h3>

<p>Unicorn 是一个为运行 Rack 应用的HTTP服务器。
Rack是为使用Ruby开发web应用提供了一个最小的模块化和可修改的接口。用可能最简单的方式来包装HTTP请求和响应</p>

<p>与上下的关联
1. read/parse HTTP request headers in full
2. call Rack application（Sinatra）
3. write HTTP response back to the client</p>

<p>/Users/tywang/WuhanWork/sales-funnel/config.ru是入口文件
/Users/tywang/WuhanWork/sales-funnel/unicorn.rb
参考：<a href="https://unicorn.bogomips.org/Unicorn/Configurator.html#method-i-worker_processes">https://unicorn.bogomips.org/Unicorn/Configurator.html#method-i-worker_processes</a></p>

<p>unicorn.rb:</p>

<pre><code>#where do app live???
@dir = "/usr/share/nginx/sales_refresh_app/"

worker_processes 8
working_directory @dir

#设置worker_processes的超时时间（handling the request/app.call/response cycle）单位秒，如果超时将被sigkill
timeout 300

# Specify path to socket unicorn listens to,
# used in  nginx.conf 
listen "#{@dir}tmp/sockets/unicorn.sock" , :backlog =&gt; 64

# Set process id path
pid "#{@dir}tmp/pids/unicorn.pid"

# Set log file paths
stderr_path "#{@dir}log/unicorn.stderr.log"
stdout_path "#{@dir}log/unicorn.stdout.log"
</code></pre>

<p>以前碰到过的一个问题：不启用nginx和unicorn时，当程序出错，代码中不处理错误而是抛出错误会导致服务器挂掉，似乎sinatra也没有管。
答：thin是单线程的，如果代码不够健壮导致thin挂了一次就无法恢复了，unicorn是多线程的，worker_processes默认有8个哦，如果超时会被kill掉再启动的，每个worker_process只能同时服务一个client，所以并发性能很差</p>

<p>那么问题又来了，单线程如何实现高性能并发处理？
<a href="https://github.com/eventmachine/eventmachine">https://github.com/eventmachine/eventmachine</a></p>

<h3>Sinatra</h3>

<p>Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort
对我们来说就是一个Ruby开发框架，用Sinatra的写法简化我们的开发，一个基于Rack的框架</p>

<p>总结：Request->Nginx->Unicorn->Rack(Sinatra)->App</p>

<p>其他：Nginx+Unicorn+Sinatra部署方案
<a href="http://recipes.sinatrarb.com/p/deployment/nginx_proxied_to_unicorn">http://recipes.sinatrarb.com/p/deployment/nginx_proxied_to_unicorn</a></p>
]]></content>
  </entry>
  
</feed>
