<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tianyi's blog]]></title>
  <link href="http://xbox1994.github.io/atom.xml" rel="self"/>
  <link href="http://xbox1994.github.io/"/>
  <updated>2016-12-25T19:14:39+08:00</updated>
  <id>http://xbox1994.github.io/</id>
  <author>
    <name><![CDATA[Tianyi Wang]]></name>
    <email><![CDATA[tywang@thoughtworks.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[你的名字。]]></title>
    <link href="http://xbox1994.github.io/blog/2016/12/25/ni-de-ming-zi-./"/>
    <updated>2016-12-25T15:57:48+08:00</updated>
    <id>http://xbox1994.github.io/blog/2016/12/25/ni-de-ming-zi-.</id>
    <content type="html"><![CDATA[<p>某夜,趟雨,迟到5分钟,坐下,观影,值了.</p>

<!--more-->


<p>这是我看过为数不多的电影之一,但这部电影的剧情是给我感触最深的.全剧可分为三个层次,每个层次内部有很强的主旨,但又有一条主线索贯穿其中.让人沉迷其中.</p>

<h2>若即若离</h2>

<p>若有若无的联系,情感是最为微妙的,非常容易迷住观众,引人入胜.</p>

<p>梦中交换身体,邂逅彼此,过着梦想的和从来没有过的生活,用文字约束着交流着.</p>

<p>&ldquo;姐姐你什么时候开始这么喜欢摸自己的胸啊.&rdquo;,&ldquo;你打太多份工了啊.&rdquo;&ldquo;还不是因为你乱花钱啊.&rdquo; 非常多有趣的细节让观众乐在其中,不过令我印象最为深刻的还是两人之间从若有若无的联系到试图寻找对方的时刻,因为此时,两人已经无法分离.</p>

<h2>命中注定&amp;&amp;握在手里</h2>

<p>陨石掉落,再也见不到三叶了,看似一切都是命中注定,但是还好这是在电影中,一切都可以重新开始.让泷喝下孟婆汤,随后注定的是一场拯救.</p>

<p>人总是在寻找某个人,人总是在等待某个人,这样便产生了希望.泷一直在寻找三叶,拼了命的要救三叶,虽然他们一次都没有真正见过面,虽然三叶已经过世,但是命中注定是他们会相见的.</p>

<p>你可以说这就是剧本,剧本里的一切都是那么美好,即使出现跌宕起伏的情节也是为了吸人眼球.但是我发现一个最现实的一件事情就是,有个词叫做希望,就和今天过圣诞节一样,我们通常不会特别关注它的来龙去脉是如何的,而是它能给我们带来我们憧憬的美好,对爱人的眷念,只要不是狗血到不成样子的剧本或是有一些坏名声的节日,人们都会接受他,我也是这样.</p>

<h2>最怕做过的一切都是不值得的</h2>

<p>&ldquo;我好像在哪儿见过你&rdquo;,在观众都为最后一幕的擦肩而过感到心急时,泷终于说出了这句话,三叶泪流满面,&ldquo;我也是&rdquo;.这一瞬间是一个极致的泪点,以前经历过的纯粹的爱情终于.但是,我好怕三叶没有被救回,好怕他们最后没有相见,好怕泷犹豫不决,好怕一切都是不值得的.</p>

<p>&ldquo;我好像在哪儿见过你&rdquo;,台词有写到,歌词有唱到,平时有说到.万一没有认出来呢,&ldquo;我好像是在哪里见过你,但是想不起来了,可能是上辈子或者梦中见到过吧&rdquo;.让我们相信"人世间所有的相遇都是久别重逢"也许是最有正能量的信念,能让我们珍惜眼前人.</p>

<p>但是如果真的没有认出来呢?很多现实因素会导致这个结果,那么做过的一切都是不值得吗? &ldquo;我喜欢你&rdquo;&ldquo;笨蛋你这样我怎么知道你叫什么啊&rdquo;</p>

<h2>PS</h2>

<p>如果在一些字词中加入某种联系之后,产生羁绊,一切都变得美好了起来:<br/>
某个命中注定的夜晚,趟着淅淅沥沥的小雨,赶到了我的座位上,虽然迟到了5分钟,但看完发现然而并没有什么影响,看完了这部让我很有感触的电影,想到了遇到过的人与事,这部电影在情感细节方面扣的很过分,但就是这样才是我想要的,值.</p>

<p>&ldquo;这电影怎么这么乱,我就记得他们一直在跑啊跑啊跑啊的&rdquo;,&ldquo;算了吧,你这小伙子这智商完全跟我们不在一个频道上&rdquo;.下电梯时在人群中听到这番闲聊.但是,有什么问题呢?跑,是真的可以概括这部大作.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NUS后台]]></title>
    <link href="http://xbox1994.github.io/blog/2016/12/18/nusde-hou-tai/"/>
    <updated>2016-12-18T16:12:24+08:00</updated>
    <id>http://xbox1994.github.io/blog/2016/12/18/nusde-hou-tai</id>
    <content type="html"><![CDATA[<p>Nginx Unicorn Sinatra<br/>
研究一个后台架构,客户端发送的请求最开始是由是Nginx接收的,随后反向代理发送给Unicorn服务器的一个线程,接下来是Sinatra框架和Rack负责处理</p>

<!--more-->


<h3>Nginx</h3>

<p>是一个高性能的HTTP和反向代理服务器</p>

<p>根据以下文件你可以发现在SF中我们是如何使用nginx的
infrastructure/ansible/roles.add_app_to_nginx/files/sales_refresh_app_nginx_config</p>

<pre><code>server {
    #监听端口号
    listen 80;
    #会根据收到的HOST来匹配哪一个server，这样随便写没有匹配到的，那么第一个就是默认的
    server_name _;
    #重定向http请求为https
    return 301 https://$http_host$request_uri;
}

upstream unicorn_server {
    #IPC方式与unicorn通信，unicorn.rb
    server unix:/usr/share/nginx/sales_refresh_app/tmp/sockets/unicorn.sock
    #0让nginx反复重试后端即使超时，配合下面的unicorn配置文件使用
    fail_timeout=0;
}

server {
    listen 443;
    server_name _;
    #可直接访问静态文件
    root /usr/share/nginx/sales_refresh_app/public;
    ssl on;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_certificate /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;
    location / {
    #先查找是否有可以直接访问的文件，然后再去访问app
    try_files $uri @app;
    }
    location @app {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    # pass to the upstream unicorn server mentioned above
    proxy_pass http://unicorn_server;
    }
}
</code></pre>

<p>总结：在本机上同时使用nginx和unicorn，所以用到了反向代理，没有用到负载均衡。只提供https协议访问。静态文件加速访问。配置与unicorn的关系。</p>

<h3>Unicorn</h3>

<p>Unicorn 是一个为运行 Rack 应用的HTTP服务器。
Rack是为使用Ruby开发web应用提供了一个最小的模块化和可修改的接口。用可能最简单的方式来包装HTTP请求和响应</p>

<p>与上下的关联
1. read/parse HTTP request headers in full
2. call Rack application（Sinatra）
3. write HTTP response back to the client</p>

<p>/Users/tywang/WuhanWork/sales-funnel/config.ru是入口文件
/Users/tywang/WuhanWork/sales-funnel/unicorn.rb
参考：<a href="https://unicorn.bogomips.org/Unicorn/Configurator.html#method-i-worker_processes">https://unicorn.bogomips.org/Unicorn/Configurator.html#method-i-worker_processes</a></p>

<p>unicorn.rb:</p>

<pre><code>#where do app live???
@dir = "/usr/share/nginx/sales_refresh_app/"

worker_processes 8
working_directory @dir

#设置worker_processes的超时时间（handling the request/app.call/response cycle）单位秒，如果超时将被sigkill
timeout 300

# Specify path to socket unicorn listens to,
# used in  nginx.conf 
listen "#{@dir}tmp/sockets/unicorn.sock" , :backlog =&gt; 64

# Set process id path
pid "#{@dir}tmp/pids/unicorn.pid"

# Set log file paths
stderr_path "#{@dir}log/unicorn.stderr.log"
stdout_path "#{@dir}log/unicorn.stdout.log"
</code></pre>

<p>以前碰到过的一个问题：不启用nginx和unicorn时，当程序出错，代码中不处理错误而是抛出错误会导致服务器挂掉，似乎sinatra也没有管。
答：thin是单线程的，如果代码不够健壮导致thin挂了一次就无法恢复了，unicorn是多线程的，worker_processes默认有8个哦，如果超时会被kill掉再启动的，每个worker_process只能同时服务一个client，所以并发性能很差</p>

<p>那么问题又来了，单线程如何实现高性能并发处理？
<a href="https://github.com/eventmachine/eventmachine">https://github.com/eventmachine/eventmachine</a></p>

<h3>Sinatra</h3>

<p>Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort
对我们来说就是一个Ruby开发框架，用Sinatra的写法简化我们的开发，一个基于Rack的框架</p>

<p>总结：Request->Nginx->Unicorn->Rack(Sinatra)->App</p>

<p>其他：Nginx+Unicorn+Sinatra部署方案
<a href="http://recipes.sinatrarb.com/p/deployment/nginx_proxied_to_unicorn">http://recipes.sinatrarb.com/p/deployment/nginx_proxied_to_unicorn</a></p>
]]></content>
  </entry>
  
</feed>
